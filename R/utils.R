#' Plot wrapper
#'
#' Wrapper around splice plotting function for a nexons output file.
#'
#' @param nexons_output_file gtf file output from nexons
#' @param order_splices (one of 'score', 'name', NULL) default NULL. How to order the splices on the y axis.
#' @param quant_plot TRUE or FALSE, whether to display a quantitative plot
#' alongside the splice picture
#' @param min_count minimum number of times the splice variant must be present to
#' be display. Any splice variants with counts < min_count will be filtered out.
#'
#' @return splice plot
#' @export
#'
#' @examples
#' file <- system.file("extdata", "nexons_sirv5_f15.gtf", package = "nexonsAnalysis")
#' # just the splice picture
#' plot_wrapper(file, min_count = 5)
#' plot_wrapper(file, min_count = 5, order_splices = "name")
#' # including a quantitative plot
#' plot_wrapper(file, quant_plot = TRUE, min_count = 5, order_splices = "score")
plot_wrapper <- function(nexons_output_file, order_splices = NULL, quant_plot = FALSE, min_count = 1){

  nexons_output <- readr::read_tsv(nexons_output_file)
  parsed_splices <- parse_nexons_gtf(nexons_output, min_count = min_count)
  draw_splice_picture(parsed_splices, quant = quant_plot, order_splices = order_splices)

}

#' Parse gtf output from nexons
#'
#' Takes a gtf file generated by nexons and separates the attribute column
#' into Transcript_id, Gene_id and splice_pattern
#'
#' @param nexon_gtf gtf file generated by nexons
#' @param min_count minimum count for transcript to be displayed (default: 1)
#'
#' @return tibble containing the columns "variant", "strand", "score", "Transcript_id", "Gene_id", "splice_pattern"
#' @export
#'
#' @examples
#' file <- system.file("extdata", "nexons_sirv5_f15.gtf", package = "nexonsAnalysis")
#' nexons_output <- readr::read_tsv(file)
#' parsed_splices <- parse_nexons_gtf(nexons_output)
#'
#' @importFrom magrittr %>%
parse_nexons_gtf <- function(nexon_gtf, min_count = 1){
  nexon_gtf %>%
    dplyr::select(strand, score, attribute) %>%
    tidyr::separate(attribute, sep = "; ", into = c("Transcript_id", "Gene_id", "splice_pattern")) %>%
    dplyr::mutate(Transcript_id = gsub("transcript_id ", "", Transcript_id)) %>%
    dplyr::mutate(Gene_id = gsub("gene_id ", "", Gene_id)) %>%
    dplyr::mutate(splice_pattern = gsub("splicePattern ", "", splice_pattern)) %>%
    dplyr::arrange(Transcript_id) %>%
    dplyr::filter(score >= min_count) %>%
    dplyr::group_by(Gene_id) %>%
    dplyr::mutate(variant = 1:dplyr::n()) %>%
    dplyr::ungroup()
}


#' Parse default nexons output
#'
#' Takes a default nexons output file (not a gtf - see parse_nexons_gtf) and makes it
#' compatible, so that it can be used as input to draw_splice_picture
#'
#' @param nexons_output dataframe containing columns named "Gene ID", "Strand", "SplicePattern", "Transcript id" and one containing the scores, the name of which is specified in the score_column argument
#' @param score_column name of the column containing the scores
#' @param min_count minimum count for the splice pattern to be included (default: 1)
#'
#' @return tibble containing the columns "variant", "strand", "score", "Transcript_id", "Gene_id", "splice_pattern"
#' @export
#'
#' @examples
#' file <- system.file("extdata", "sirv5.txt", package = "nexonsAnalysis")
#' nexons_output <- readr::read_delim(file)
#' parsed_splices <- parse_default_nexons(nexons_output, score_column = "seqs_sirv5_minimap.sam")

parse_default_nexons <- function(nexons_output, score_column, min_count = 1) {

  nexons_output |>
    dplyr::rename(
      Gene_id = 'Gene ID',
      splice_pattern = SplicePattern,
      Transcript_id = 'Transcript id',
      strand = Strand,
      score = .data[[score_column]]
    ) |>
    dplyr::arrange(Transcript_id) |>
    dplyr::filter(score >= min_count) |>
    dplyr::group_by(Gene_id) |>
    dplyr::mutate(variant = 1:dplyr::n()) |>
    dplyr::ungroup()
}

#' Add exon loci
#'
#' parses splice patterns, adding 2 columns (start and end of exon) to a dataframe
#' containing the splice patterns
#'
#' @param splice_data dataframe that contains a column named splice_pattern
#'
#' @return original dataframe with additional columns (and therefore rows) for
#' start and end of each exon in the splice pattern
#'
#' @export
#'
#' @examples
#' NA
#'
#' @importFrom magrittr %>%
add_exon_loci <- function(splice_data){
  splice_data %>%
    dplyr::mutate(full_pattern=splice_pattern) %>%
    tidyr::separate_rows(splice_pattern,sep=":") %>%
    tidyr::separate(splice_pattern, into=c("start","end"), sep="-", convert=TRUE) %>%
    dplyr::mutate(end=as.integer(end)) %>%
    dplyr::mutate(end=dplyr::if_else(is.na(end),start,end))
}


#' identifyPotentialTruncations
#'
#' Identifies whether transcripts might be truncations of other transcripts.
#'
#' @param parsed_splices tibble containing set of splices - output from \code{\link{parse_nexons_gtf}}
#' @param flexibility integer value - number of bases away to still be classified as a match. For exact matches set flexibility to 0. Default: 10
#'
#' @return modified tibble with additional column named truncation_origin
#' @export
#'
#' @examples
#' file <- system.file("extdata", "nexons_sirv5_f15_trunc.txt", package = "nexonsAnalysis")
#' nexons_output <- readr::read_delim(file)
#' parsed_splices <- parse_nexons_gtf(nexons_output, min_count = 3)
#' parsed_with_trunc <- identifyPotentialTruncations(parsed_splices)
#'
identifyPotentialTruncations <- function(parsed_splices, flexibility = 10){
  # extract splice patterns and variant numbers from parsed_splices.
  # put them into a list where names are variant names/numbers
  all_junctions <- parsed_splices %>%
    dplyr::select(variant, splice_pattern) %>%
    tibble::deframe() %>%
    purrr::map(.f=spliceStartsEnds)

  trunc_results <- purrr::map(.x=all_junctions, function(trunc) {
    purrr::map_lgl(.x=all_junctions, .f=checkTruncation, potential_truncs=trunc, flexibility=flexibility)
  })

  individual_results <- purrr::map(trunc_results, ~as.vector(which(.x)))

  tibble_results <- purrr::map_chr(individual_results, ~paste(.x, collapse = ", ")) %>%
    tibble::enframe(name = "variant", value = "truncation_origin") %>%
    dplyr::mutate(variant = as.numeric(variant)) %>%
    dplyr::mutate(truncation_origin = dplyr::if_else(truncation_origin == "", "none", truncation_origin))

  parsed_splices %>%
    dplyr::left_join(tibble_results)

}

#' spliceStartsEnds
#' Takes a splice string in the format "8381:8455-8585:10859-10991:11312" and converts it to a tibble of start and end points of splice junctions.
#' Used internally by \code{\link{identifyPotentialTruncations}} function.
#'
#' @param splice_string set of splices in the format 8381:8455-8585:10859-10991:11312"
#'
#' @return tibble of start and end points of splice junctions
#' @export
#'
#' @examples
#' splice <- "8381:8455-8585:10859-10991:11312"
#' spliceStartsEnds(splice)
spliceStartsEnds <- function(splice_string){
  splices <- stringr::str_split(splice_string, pattern = "-")[[1]]
  tibble::enframe(splices, name = "junction_no") %>%
    tidyr::separate(value, into = c("start", "end"), sep = ":", convert=TRUE)
}

#' Check junction matches
#' Check if 2 sets of splice junctions match.
#'
#' @param set1 tibble with column names junction_no, start, end
#' @param set2 tibble with column names junction_no, start, end
#' @param flexibility integer value - number of bases away to still be classified as a match. For exact matches set flexibility to 0.
#'
#' @return vector of TRUE and FALSE values
#' @export
#'
#' @examples
#' NA
checkJunctionMatches <- function(set1, set2, flexibility){
  set1$start <= set2$start+flexibility &
    set1$start >= set2$start-flexibility &
    set1$end <= set2$end+flexibility &
    set1$end >= set2$end-flexibility
}


#' checkTruncation
#'
#' Checks one set of splice junctions against another set, to see if one is a potential truncation of the other.
#' Does an initial check for the first splice junction location, then do an exact test (within flexibility parameter) for vectors of the same length.
#'
#' @param other_set tibble - one set of splice junctions
#' @param potential_truncs tibble - one set of splice junctions to test to see if they might be truncations
#' @param flexibility integer value - number of bases away to still be classified as a match. For exact matches set flexibility to 0.
#'
#' @return TRUE or FALSE value
#' @export
#'
#' @examples
#' NA
checkTruncation <- function(other_set, potential_truncs, flexibility) {

  if(nrow(potential_truncs) >= nrow(other_set)) return(FALSE) # if potential_trunc is longer then reject

  # check for first junction match
  junction1 <- checkJunctionMatches(dplyr::slice(potential_truncs, 1), other_set, flexibility=flexibility)
  if(all(junction1 == FALSE)) return(FALSE) # reject if no match

  # extract the first junction number that mapped
  junction1_no <- dplyr::filter(other_set, junction1) %>% dplyr::pull(junction_no)

  # subset consecutive junctions
  subset <- other_set %>%
    dplyr::slice(junction1_no:dplyr::n()) %>%
    dplyr::slice_head(n=nrow(potential_truncs))

  # test whole set to see if each junction matches
  x <- checkJunctionMatches(potential_truncs, subset, flexibility=flexibility)

  if(any(x == FALSE)) return(FALSE)
  return(TRUE) # potential truncation
}








